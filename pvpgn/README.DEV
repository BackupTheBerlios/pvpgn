
		    PVPGN (wannabe) DEVELOPERS GUIDE

           Please read this file before asking any questions !

0. About this document
=======================

This document was initially started by dizzy , then beeing
updated by other devs too, also updated considering other people's sugestions.
This document is intended to be read by all of you out there wanting to devs
for PvPGN.

ChangeLog:
29-07-2003: dizzy : Initial version
28-08-2004: dizzy : Run-time debugging : Appendix A

1. Why ?
=========

You want to start coding for PvPGN ? Why ? What do you expect to get from it ?
Answer yourself this questions and then go to the next paragraph.

2. History
===========

PvPGN has started as a game server emulation project, taking the excelent's
bnetd project source and working on it. While initially it has started as
a War3 emulation patch over bnetd it become a lot more than that (lots of
new features, lots of code changes organizing). Because of the code roots
you will notice a lot of things still carrying the "bnetd" word (most notable
examples are the main servers program file called "bnetd" or the main server
configuration file called bnetd.conf). We considered that as a sign of respect
from us to the bnetd coders we keep their names on the code they written (but
on the new code of course we may name them different).

3. Objective
=============

PvPGN's main objective is to support all Battle.Net clients (games) but are
considering in the near future to extend it to support other game protocols
as well.

4. Layout of files
===================

Note: Starting here on you may find lots of terms and wors which may sound
"strange" to you and for this reason we have included a glossary of terms
in the end of this file.

The PvPGN project consists of a main server (called "bnetd") and various
other programs and (little) servers (ex. bnchat, d2cs, d2dbs etc...).

PvPGN follows the bnetd's layout of files:
./bin			-> used to store binaries (after compilation)
./conf			-> configuration files (many of them templates)
./files			-> various files needed for clients connecting
./man			-> outdated man pages :(
./sbin			-> same as ./bin
./scripts		-> various scripts for testing/managing pvpgn
./src			-> the source main directory
./src/bnetd		-> source files used only by the main server
./src/common		-> source files used in common by different programs
./src/compat		-> source files concerning portability of code
...

The build process takes place in the "src" dir.

5. Coding Style
================

a. General

PvPGN is mainly developed on and for UNIX/Linux. The reasons are because we
as coders work on this systems and because our users (at least the big ones)
use UNIX/Linux more than ex. Windows. But, even so we try to code in a portable
fashion and any release PvPGN had we made sure it compiles on win32 too (we
even release win32 binaries). We will never refuse a good win32 coder but we
prefer UNIX ones ;)

One thing which is overlooked by newbie coders is the "esthetical" side of the
code. It may not be so important to many people (which code on the idee "if it
works then its good") but for us, coding on PvPGN is VERY important. When you
are coding for PvPGN PLEASE try to make your code look similar to already 
written code (this includes identing, identificator names, etc...). Keeping
the code look "the same" makes its reading a lot more easier so, finding
bugs easier so coding better.

One way to make sure your code sticks with the PvPGN coding style is to use 
"indent" code indenting formating tool (http://www.gnu.org/software/indent/). 
To use indent to get your code acording to PvPGN coding style use something 
like this (it will format properly the file clan.c and save the new file to 
clan.c.new):
$ indent -kr -bl -bli0 -l0 clan.c -o clan.c.new

Other overlooked aspect for newbie coders is code replication. Please DONT
copy and paste code arround !!! If you need to copy common functionality from
some place, think about making some API of that functionalilty, put it in
some functions and use it from both places. I repeat, DONT replicate code.

When allocating memory inside a function always free it in the same function
before its exit (exceptions: the function returns the allocated memory in
which case the calling function should take care of the allocated memory;
or the allocated memory is cached/stored somewhere to be used later, in which
case you must make sure it will be free()d when not needed anymore).

In the startup code of any "external" function (function which may be called
from other modules then the one containing it) please check ALL the input
parameters (you will notice how PvPGN already does that in such functions).

When developing code you should compile always with "all warnings" enabled 
and try to fix them (some warnings uncover real bugs), like for gcc use 
"-Wall". When running/testing the codes you should use a memory debugger like 
valgrind and/or bounds checking compiler patches like bounds-checking-gcc. 
For more details about how to run pvpgn check Appendix A.

b. Code Organizing

PvPGN (inhireted from bnetd) trys to group functions based on their data on
which they work on. Thus it somewhat resembles the principle of data
encapsulation used in OOP. For example connection.h defines structs necesarry
to work with connections (the main one beeing t_connection) and functions
which work with this structs and which do actions related to this connections.
Also notice that all this functions are named like conn_<name>(). In general
if you have a set of functions working on a set of structs, you define the
structs and the functions in a <module>.h file (thus defining the API) then
write the function implementations in <module>.c file. And the function names
should be something like <module>_<name>(). Separating and grouping functions
in their own modules, working on their own data structures helps isolating
functionality in the server and thus hunting bugs a lot easier.

c. Code Flow

Note: this chapter is more or less correct. Is intended to give a general
ideea about the code flow, it may contain flows and things which are not
in sync with the actual code, for a better understanding I recommend reading
the actual code

The server starts in main() found in bnetd/main.c file. There it parses
command line arguments then tries to initilize the modules by calling their
initilizing function (many of them called like <module>_init()). Some of this
modules depend on the initilizing of others so the order there may be important.
Also some of the modules if fail on initilizing may represent a general fail
thus PvPGN bails out. But should print out a explaining message (or write it
to the log configured file).

From there the server calls the main server loop function found in server.c.
Here the loop may be simplified to something like:
1. select()/poll() on the set of opened sockets
2. read (if any) network data and "handle" them (by calling the handle function
coresponding to the class of the connection receiving the data)
3. write (if any) to the network from the output queue
4. do any periodic or time based events
5. go to 1

As seen on step 2. above we call the handling functions coresponding to the
class of the connection. The handle functions usualy are a big switch/case or
a for/if (which is equivalent) and they check for the packet type received, then
they act acordingly to the data received (many of them responing with packets
by adding them to the output packet queue of the connection).

6. Glossary of terms
=====================

* autoupdate: the feature of Battle.Net servers to send a (MPQ, see MPQ) file
to the client which after downloading it, it is used to update the client

* connection class: when a connection is established to a bnet listening
address the client sends an initial byte which tells the server of what class
of connection the following packets will be; classes of connections determine
what packets can go through that connection.

* MPQ: a format archive which is used by Blizzard clients and Battle.Net 
servers. This files are used for containing verious files (sound/graphics in
clients, AI scripts, update patches etc...)

* versioncheck: also know as vcheck and sometimes just vc ; a client 
verification system used by Battle.Net servers to identify client version and 
"purity". Based on this the server may accept/refuse connection or ask for 
upgrade (see autoupdate).

Appendix A
============

It is very helpfull in finding out memory coruption bugs as soon as possible 
so while developing codes or just when running a server it is good that you 
use some memory coruption run-time debuggers. I dont know about Win32 users 
but on Unix/Linux there are some good options.

1. valgrind (http://valgrind.kde.org)

Valgrind is not very portable (only x86, Linux and very recently FreeBSD), 
also it slows down the debugged codes (it acts like a CPU emulator so it 
has to do that) but I have yet to find out a better debugging tool for what 
he does. Valgrind is so cool that recently many OSS projects use it for 
finding out bugs in their codes. For more information you can check out their 
web page. I will focus on valgrind with PvPGN.

After you have compiled and installed valgrind (it's easy, ./configure, make, 
make install) you will use it by running PvPGN like this:

$ valgrind --tool=memcheck --num-callers=10 /path/to/bnetd -f 2> valg.out

"num-callers" makes valgrind record backtraces with 10 entries and is usually 
needed with PvPGN which has not very small backtrace path :)

Another option you might want to use is "--leak-check=yes" and probably 
"--leak-resolution=high". This options make valgrind even slower but they 
will give memory leak information when PvPGN exits.

I encourage EVERYONE to use it if available (that is if you run PvPGN on 
a supported platform). Only very big servers won't be able to do it because 
there is no hardware powerfull enough to run a big server with valgrind (but 
big means over 500 users online). You should test it with your server and if 
it does not make your bnetd go over 90% CPU then you should be fine. If you 
cannot run valgrind for any reason or if you are hunting for some bugs 
valgrind cannot find (yes, valgrind is superb but there is a class of bugs, 
especially overflows which valgrind can't help you with) you should then try 
the next debugging tool.

2. bounds-checking GCC (http://sourceforge.net/projects/boundschecking/)

This has the drawback of beeing just for GCC (as far as I know of) but has 
the advantage over valgrind that is : more portable (virtually it should be 
possible to use it anywhere you can use a recent GCC), a lot faster and can 
detect bugs that valgrind cannot find. However it has the disadvantage that 
it's error reports do not contain backtraces so they might be lesser usefull.

To use it basically it cuts down to:
- download a recent compiler (ex GCC 3.4.1)
- download the coresponding patch from the project's sf.net page
- apply the patch while beeing in the gcc source dir you unpacked with a 
command like bunzip2  -c /path/to/patch.bz2 | patch -p1
- compile gcc and install gcc
- to make pvpgn compile with your new gcc do something like:
$ CC=/path/to/new/gcc CFLAGS="-O0 -Wall -fbounds-checking -g" ./configure
- then the usual make, make install
- to run PvPGN you will probably need to redirect stderr like:
$ /path/to/bnetd -f 2> debug.out

You will probably encounter some problems when configuring, building gcc, so 
you should read the text in the beginning of the bounds-checking patch file. 
Also the gcc install docs are usefull.

When starting up your new bounds checking enabled binary you will see some 
usefull messages. By default the patch makes the debugged program exit on the 
first error it encounters. For a production server this is not very nice so 
you will want to set GCC_BOUNDS_OPTS shell variable to "-never-fatal" like:
$ GCC_BOUNDS_OPTS="-never-fatal" /path/to/bnetd -f 2> debug.out
